include ActionView::Helpers::NumberHelper

class EfsReports::EfsReport #< ActiveRecord::Base
  include ActiveModel::Model

  attr_accessor :section_classes, :sections
  attr_accessor :criteria_classes, :criteria, :description
  attr_accessor :group_by_options, :group_by_default, :order_by_default, :order_by_direction_default
  attr_accessor :output, :additional_controls, :title, :current_user, :current_actual_user, :debt_logic_admin_only
  attr_accessor :params, :internal_params, :report_id, :criteria_errors

  attr_accessor :location_id, :wide_report, :single_table, :report_wrapper_class
  attr_accessor :report_subscription, :report_customization

  def initialize(args)
    self.current_user = args[:user]
    self.current_actual_user = args[:real_user]
    self.params = args[:params] || {}
    self.internal_params = args[:internal_params] || {}
    self.report_id = args[:report_id]
    self.criteria = Hash.new
    self.criteria_errors = Array.new
    self.wide_report = true
    self.report_subscription = args[:report_subscription]
    self.report_customization = args[:report_customization]

    @criteria_classes.each do | criteria_class |
      criterion = criteria_class.new(:report => self)
      self.criteria[criteria_class] = criterion
    end

    self.title = self.report_subscription.name if self.report_subscription.present? && !self.report_subscription.name.blank?
  end

  def admins_only
    false
  end

  def report_class
    self.class.to_s.split('::').last.underscore
  end

  def default_params
  end

  def allow_subscription
    true
  end

  def validate
    # Clean / validate criteria
    @criteria.each do | criterion_class, criterion |
      criterion.validate(self.params)
    end
    
    return @criteria_errors.empty?
  end
  
  def run_report(run_queries, cache_data = false)
    self.sections = Hash.new
    
    # Iterate through the sections of the report, running each query
    @section_classes.each do | section_data |

      if section_data.is_a?(Hash)
        section_class = section_data.keys.first
        section_params = section_data.values.first
        self.params.merge!(section_params)
        section_id = section_class.name.split('::').last.underscore + '_' + section_params.values.join('_').underscore
      else
        section_class = section_data
        section_id = section_class.name.split('::').last.underscore
      end

      section = section_class.new(:user => current_user, :real_user => current_actual_user, :single_table => self.single_table, :report => self, :section_id => section_id)
      self.sections[section_data] = section

      if run_queries
        section.configure_query()
        section.add_sort_to_query()

        raw_data = nil
        cache_key = nil

        if cache_data
          cache_key = "renter-insight-#{@current_user.id}-#{self.params.to_json}-#{section.section_id}"
          raw_data = Rails.cache.read(Base64.encode64(cache_key))
        end

        if raw_data.nil? || raw_data.empty?
          section.pull_data()

          if cache_data
            Rails.cache.write(Base64.encode64(cache_key), section.raw_data, {expires_in: 1.hour})
          end
        else
          section.raw_data = raw_data
        end
      end
    end

    if run_queries
      # Iterate through the sections of the report, appending the output
      @sections.each do | section_data, section |
        section.arrange_data()
      end
    end
  end
  
  def generate_html(for_pdf = false)
    html_parts = ["<div id=\"report-output\" class=\"#{self.wide_report ? 'report-wide' : ''}\">"]
    html_parts << '<table class="report-data">' if self.single_table

    first_section_displayed = false

    @sections.each do | section_data, section |

      if (!section.hide_if_empty || !section.data_is_empty?) && section.are_columns_visible?
        section.generate_html(for_pdf)
        html_parts << section.output

        if !first_section_displayed
          first_section_displayed = true
          html_parts << '<div id="report-sections">'
        end
      end

    end

    html_parts << '</table>' if self.single_table
    html_parts << '</div>' if first_section_displayed
    html_parts << '</div>'

    self.output = html_parts.join("\n")
  end

  def generate_pdf

    crypt = ActiveSupport::MessageEncryptor.new(Rails.application.secrets.secret_key_base)

    url = "#{Rails.application.config.action_mailer.asset_host}/reports/#{self.report_class}/run"
    url += "?pdf=true&uid=#{crypt.encrypt_and_sign(self.current_user.id)}&#{{report: self.params}.to_query}"

    # The PDF is based on HTML generated by calling back to the server
    kit = PDFKit.new(url, :orientation => 'Landscape', :page_size => 'Legal')

    self.output = kit.to_pdf
  end
  
  def generate_csv
    csv_parts = []

    @sections.each do | section_class, section |
      if !section.hide_if_empty || !section.data_is_empty?
        section.generate_csv()
        csv_parts << section.output
        csv_parts << CSV.generate_line([])
      end
    end

    self.output = csv_parts.join("")
  end
  
  def get_section_by_class(klass)
    return @sections[klass]
  end

  def get_data_specific_color(row)
    nil
  end

  def to_builder
    Jbuilder.new do |json|
      json.title title
      json.params params
      json.criteria criteria.keys.collect{| criteria_key | criteria[criteria_key].to_builder.attributes!} if criteria.present?
      json.description description
      json.criteria_errors criteria_errors
      json.report_wrapper_class report_wrapper_class
      json.sections sections.keys.collect{| section_key | sections[section_key].to_builder.attributes!} if sections.present?
    end
  end
end